/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !(function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    })(exports, (function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = (function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = (function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          })(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, (function(t3, r3) {
            return r3 || (function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            })(t3) || i2.replace(":", "");
          }));
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      })(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      })), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    }));
  }
});

// node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "node_modules/dayjs/plugin/customParseFormat.js"(exports, module2) {
    !(function(e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    })(exports, (function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var f = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = (function(e3) {
          if (!e3) return 0;
          if ("Z" === e3) return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        })(e2);
      }], u = function(e2) {
        var t2 = s[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, d = function(e2, t2) {
        var n2, r2 = s.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1) if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
        } else n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, c = { A: [o, function(e2) {
        this.afternoon = d(e2, false);
      }], a: [o, function(e2) {
        this.afternoon = d(e2, true);
      }], Q: [n, function(e2) {
        this.month = 3 * (e2 - 1) + 1;
      }], S: [n, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [r, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
        var t2 = s.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2) for (var r2 = 1; r2 <= 31; r2 += 1) t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
        var t2 = u("months"), n2 = (u("monthsShort") || t2.map((function(e3) {
          return e3.slice(0, 3);
        }))).indexOf(e2) + 1;
        if (n2 < 1) throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [o, function(e2) {
        var t2 = u("months").indexOf(e2) + 1;
        if (t2 < 1) throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
        this.year = a(e2);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l(n2) {
        var r2, i2;
        r2 = n2, i2 = s && s.formats;
        for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e2, t3, n4) {
            return t3 || n4.slice(1);
          }));
        }))).match(t), a2 = o2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = o2[f2], u2 = c[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
          o2[f2] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = o2[n3];
            if ("string" == typeof i3) r3 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return (function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          })(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
          this.$u = r3;
          var a2 = o2[1];
          if ("string" == typeof a2) {
            var f2 = true === o2[2], h2 = true === o2[3], u2 = f2 || h2, d2 = o2[2];
            h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = (function(e4, t4, n3, r4) {
              try {
                if (["x", "X"].indexOf(t4) > -1) return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
                o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            })(t3, a2, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array) for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
            o2[1] = a2[m - 1];
            var M = n2.apply(this, o2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else i2.call(this, e3);
        };
      };
    }));
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimelinePlugin
});
module.exports = __toCommonJS(main_exports);

// src/types/index.ts
var DEFAULT_SETTINGS = {
  defaultView: "timeline",
  timelineOrder: "asc",
  showHeaderButtons: true,
  dateFormat: "YYYY-MM-DD"
};
var TimelineValidationError = class extends Error {
  constructor(message, type = "validation", details, line) {
    super(message);
    this.type = type;
    this.details = details;
    this.line = line;
    this.name = "TimelineValidationError";
  }
};

// src/views/TimelineView.ts
var import_obsidian5 = require("obsidian");

// src/utils/parser.ts
function validateDate(year, month, day, lineNumber) {
  if (!year || typeof year !== "string") {
    throw new TimelineValidationError(
      "Invalid year parameter",
      "validation",
      "Year must be a non-empty string",
      lineNumber
    );
  }
  const yearNum = parseInt(year);
  if (isNaN(yearNum)) {
    throw new TimelineValidationError(
      "Invalid year format",
      "validation",
      `Year "${year}" is not a valid number`,
      lineNumber
    );
  }
  if (month) {
    const monthNum = parseInt(month);
    if (isNaN(monthNum) || monthNum < 1 || monthNum > 12) {
      throw new TimelineValidationError(
        "Invalid month format",
        "validation",
        `Month "${month}" should be between 1 and 12`,
        lineNumber
      );
    }
    if (day) {
      const dayNum = parseInt(day);
      const absYear = Math.abs(yearNum);
      const daysInMonth = new Date(absYear, monthNum, 0).getDate();
      if (isNaN(dayNum) || dayNum < 1 || dayNum > daysInMonth) {
        throw new TimelineValidationError(
          "Invalid day format",
          "validation",
          `Day "${day}" is not valid for month ${month}`,
          lineNumber
        );
      }
    }
  }
}
function parseTimelineContent(content) {
  validateContentNotEmpty(content);
  const sections = content.split("---").filter((section) => section.trim());
  validateSectionsExist(sections);
  const events = [];
  let currentLineNumber = 1;
  sections.forEach((section) => {
    const event = parseTimelineSection(section, currentLineNumber);
    events.push(event);
    currentLineNumber += section.split("\n").length + 1;
  });
  return events;
}
function validateContentNotEmpty(content) {
  if (!content.trim()) {
    throw new TimelineValidationError(
      "Empty timeline content",
      "parse",
      "Please provide some timeline events"
    );
  }
}
function validateSectionsExist(sections) {
  if (sections.length === 0) {
    throw new TimelineValidationError(
      "No timeline events found",
      "parse",
      "Timeline should contain at least one event separated by ---"
    );
  }
}
function parseTimelineSection(section, startLineNumber) {
  const lines = section.trim().split("\n");
  const currentEvent = {};
  const contentLines = [];
  let foundDate = false;
  let foundTitle = false;
  let currentLineNumber = startLineNumber;
  lines.forEach((line) => {
    line = line.trim();
    if (!foundDate && line.startsWith("# ")) {
      parseDateLine(line, currentEvent, currentLineNumber);
      foundDate = true;
    } else if (!foundTitle && line.startsWith("## ")) {
      parseTitleLine(line, currentEvent, currentLineNumber);
      foundTitle = true;
    } else if (line) {
      contentLines.push(line);
    }
    currentLineNumber++;
  });
  validateRequiredFields(foundDate, foundTitle, contentLines.length, startLineNumber);
  currentEvent.content = contentLines.join("\n");
  return currentEvent;
}
function parseDateLine(line, currentEvent, lineNumber) {
  const dateStr = line.replace("# ", "");
  const dateParts = parseDateString(dateStr);
  if (dateParts.length === 0 || dateParts.length > 3) {
    throw new TimelineValidationError(
      "Invalid date format",
      "parse",
      "Date should be in format: # [-]YYYY[-MM[-DD]], supports negative years for BC events",
      lineNumber
    );
  }
  currentEvent.year = dateParts[0];
  if (dateParts.length > 1) {
    currentEvent.month = dateParts[1];
  }
  if (dateParts.length > 2) {
    currentEvent.day = dateParts[2];
  }
  validateDate(
    currentEvent.year,
    currentEvent.month,
    currentEvent.day,
    lineNumber
  );
}
function parseDateString(dateStr) {
  if (dateStr.startsWith("-")) {
    const yearPart = dateStr.substring(0, dateStr.indexOf("-", 1) === -1 ? dateStr.length : dateStr.indexOf("-", 1));
    const restPart = dateStr.substring(yearPart.length);
    return [yearPart, ...restPart.split("-").filter((p) => p)];
  } else {
    return dateStr.split("-");
  }
}
function parseTitleLine(line, currentEvent, lineNumber) {
  currentEvent.title = line.replace("## ", "").trim();
  if (!currentEvent.title) {
    throw new TimelineValidationError(
      "Empty title",
      "parse",
      "Event title cannot be empty",
      lineNumber
    );
  }
}
function validateRequiredFields(foundDate, foundTitle, contentLength, startLine) {
  if (!foundDate) {
    throw new TimelineValidationError(
      "Missing date",
      "parse",
      "Each event must start with a date (# YYYY[-MM[-DD]])",
      startLine
    );
  }
  if (!foundTitle) {
    throw new TimelineValidationError(
      "Missing title",
      "parse",
      "Each event must have a title (## Title)",
      startLine
    );
  }
  if (contentLength === 0) {
    throw new TimelineValidationError(
      "Missing content",
      "parse",
      "Each event must have some content",
      startLine
    );
  }
}

// src/utils/timeline-renderer.ts
var import_obsidian4 = require("obsidian");

// src/constants/timeline.ts
var TIMELINE_CLASSES = {
  TIMELINE: "timeline",
  TIMELINE_HEADER: "timeline-header",
  TIMELINE_SEARCH: "timeline-search",
  TIMELINE_SEARCH_BUTTON: "timeline-search-button",
  TIMELINE_ORDER_TOGGLE: "timeline-order-toggle",
  TIMELINE_EVENT: "timeline-event",
  TIMELINE_DATE: "timeline-date",
  TIMELINE_POINT: "timeline-point",
  TIMELINE_CONTENT: "timeline-content",
  TIMELINE_MARKDOWN_CONTENT: "timeline-markdown-content"
};
var TIMELINE_ORDER = {
  ASC: "asc",
  DESC: "desc"
};
var TIMELINE_ARIA_LABELS = {
  SEARCH_BUTTON: "Search events",
  ORDER_ASC: "Sorted oldest first",
  ORDER_DESC: "Sorted newest first"
};

// src/components/TimelineAddButton.ts
var import_obsidian = require("obsidian");
var AddEventModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit, getExistingEventsContent) {
    super(app);
    if (!onSubmit || typeof onSubmit !== "function") {
      throw new Error("onSubmit must be a valid function");
    }
    if (!getExistingEventsContent || typeof getExistingEventsContent !== "function") {
      throw new Error("getExistingEventsContent must be a valid function");
    }
    this.onSubmit = onSubmit;
    this.getExistingEventsContent = getExistingEventsContent;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Add New Event" });
    const dateInput = new import_obsidian.Setting(contentEl).setName("Date").addText((text) => {
      text.setPlaceholder("YYYY[-MM[-DD]]");
      text.inputEl.style.width = "100%";
    });
    const titleInput = new import_obsidian.Setting(contentEl).setName("Title").addText((text) => {
      text.setPlaceholder("Event Title");
      text.inputEl.style.width = "100%";
    });
    const contentInput = new import_obsidian.Setting(contentEl).setName("Content").addTextArea((text) => {
      text.setPlaceholder("Markdown Content");
      text.inputEl.style.width = "100%";
      text.inputEl.style.height = "150px";
      text.inputEl.style.resize = "none";
    });
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Add Event").setCta().onClick(() => {
        var _a, _b, _c;
        const dateValue = ((_a = dateInput.settingEl.querySelector("input")) == null ? void 0 : _a.value) || "";
        if (!dateValue) {
          return;
        }
        let dateParts;
        if (dateValue.startsWith("-")) {
          const yearPart = dateValue.substring(0, dateValue.indexOf("-", 1) === -1 ? dateValue.length : dateValue.indexOf("-", 1));
          const restPart = dateValue.substring(yearPart.length);
          dateParts = [yearPart, ...restPart.split("-").filter((p) => p)];
        } else {
          dateParts = dateValue.split("-");
        }
        const formattedDate = `${dateParts[0]}${dateParts[1] ? "-" + dateParts[1] : ""}${dateParts[2] ? "-" + dateParts[2] : ""}`;
        const titleValue = ((_b = titleInput.settingEl.querySelector("input")) == null ? void 0 : _b.value) || "";
        if (!titleValue) {
          console.error("Title input is empty");
          return;
        }
        const contentValue = ((_c = contentInput.settingEl.querySelector("textarea")) == null ? void 0 : _c.value) || "";
        if (!contentValue) {
          console.error("Content input is empty");
          return;
        }
        const newEventContent = `# ${formattedDate}
## ${titleValue}
${contentValue}`;
        const toBeWrittenWholeContent = `${newEventContent}
---
${this.getExistingEventsContent()}`;
        this.updateTimelineBlock(newEventContent);
        const newEvent = {
          year: dateParts[0],
          month: dateParts[1] ? dateParts[1] : void 0,
          day: dateParts[2] ? dateParts[2] : void 0,
          title: titleValue,
          content: toBeWrittenWholeContent
        };
        this.onSubmit(newEvent);
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  updateTimelineBlock(newEventContent) {
    const file = this.app.workspace.getActiveFile();
    if (file instanceof import_obsidian.TFile) {
      this.app.vault.read(file).then((content) => {
        const timelineBlocks = content.match(
          /```timeline[\s\S]*?```/g
        );
        if (!timelineBlocks || timelineBlocks.length === 0) {
          return;
        }
        const updatedBlock = timelineBlocks[0].replace(
          "```timeline",
          `\`\`\`timeline
${newEventContent}
---
`
        );
        const updatedContent = content.replace(
          timelineBlocks[0],
          updatedBlock
        );
        this.app.vault.modify(file, updatedContent);
      }).catch((err) => {
      });
    } else {
    }
  }
};
var TimelineAddButton = class {
  constructor(container, app, onAddEvent, getExistingEventsContent) {
    this.container = container;
    this.app = app;
    this.onAddEvent = onAddEvent;
    this.getExistingEventsContent = getExistingEventsContent;
    if (!container || !(container instanceof HTMLElement)) {
      throw new Error("container must be a valid HTMLElement");
    }
    if (!app) {
      throw new Error("app must be provided");
    }
    if (!onAddEvent || typeof onAddEvent !== "function") {
      throw new Error("onAddEvent must be a valid function");
    }
    if (!getExistingEventsContent || typeof getExistingEventsContent !== "function") {
      throw new Error("getExistingEventsContent must be a valid function");
    }
    this.initializeAddButton();
  }
  initializeAddButton() {
    this.addButton = this.container.createEl("button", {
      cls: "timeline-add-button"
    });
    this.addButton.textContent = "Add new event";
    (0, import_obsidian.setIcon)(this.addButton, "plus");
    this.addButton.setAttribute("aria-label", "Add new event");
    this.addButton.addEventListener(
      "click",
      () => this.openAddEventModal()
    );
  }
  openAddEventModal() {
    new AddEventModal(
      this.app,
      this.onAddEvent,
      this.getExistingEventsContent
    ).open();
  }
};

// src/components/TimelineOrderToggle.ts
var import_obsidian2 = require("obsidian");

// src/utils/dateUtils.ts
function compareTimelineEvents(a, b) {
  if (!a || !b) {
    throw new Error("Both timeline events must be provided");
  }
  const yearA = parseInt(a.year);
  const yearB = parseInt(b.year);
  if (yearA !== yearB) {
    return yearA - yearB;
  }
  const monthA = a.month ? parseInt(a.month) : 1;
  const monthB = b.month ? parseInt(b.month) : 1;
  if (monthA !== monthB) {
    return monthA - monthB;
  }
  const dayA = a.day ? parseInt(a.day) : 1;
  const dayB = b.day ? parseInt(b.day) : 1;
  return dayA - dayB;
}
function sortTimelineEvents(events, order) {
  if (!Array.isArray(events)) {
    throw new Error("events must be an array");
  }
  if (!["asc", "desc"].includes(order)) {
    throw new Error('order must be either "asc" or "desc"');
  }
  const modifier = order === "desc" ? -1 : 1;
  return [...events].sort((a, b) => compareTimelineEvents(a, b) * modifier);
}

// src/components/TimelineOrderToggle.ts
var TimelineOrderToggle = class {
  constructor(container, initialOrder, onOrderChange) {
    this.container = container;
    this.onOrderChange = onOrderChange;
    if (!container || !(container instanceof HTMLElement)) {
      throw new Error("container must be a valid HTMLElement");
    }
    if (!Object.values(TIMELINE_ORDER).includes(initialOrder)) {
      throw new Error("initialOrder must be a valid timeline order");
    }
    if (!onOrderChange || typeof onOrderChange !== "function") {
      throw new Error("onOrderChange must be a valid function");
    }
    this.currentOrder = initialOrder;
    this.initializeOrderToggle();
  }
  initializeOrderToggle() {
    this.orderButton = this.container.createEl("button", {
      cls: TIMELINE_CLASSES.TIMELINE_ORDER_TOGGLE
    });
    this.updateOrderButton();
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.orderButton.addEventListener("click", () => {
      this.currentOrder = this.currentOrder === TIMELINE_ORDER.ASC ? TIMELINE_ORDER.DESC : TIMELINE_ORDER.ASC;
      this.updateOrderButton();
      this.onOrderChange(this.currentOrder);
    });
  }
  updateOrderButton() {
    this.orderButton.empty();
    (0, import_obsidian2.setIcon)(this.orderButton, this.currentOrder === TIMELINE_ORDER.ASC ? "arrow-up" : "arrow-down");
    this.orderButton.setAttribute(
      "aria-label",
      this.currentOrder === TIMELINE_ORDER.ASC ? TIMELINE_ARIA_LABELS.ORDER_ASC : TIMELINE_ARIA_LABELS.ORDER_DESC
    );
  }
  getCurrentOrder() {
    return this.currentOrder;
  }
  sortEvents(events) {
    return sortTimelineEvents(events, this.currentOrder);
  }
};

// src/components/TimelineSearch.ts
var import_obsidian3 = require("obsidian");
var TimelineSearch = class {
  constructor(container, onSearch, initialSearchQuery = "") {
    this.container = container;
    this.onSearch = onSearch;
    if (!container || !(container instanceof HTMLElement)) {
      throw new Error("container must be a valid HTMLElement");
    }
    if (!onSearch || typeof onSearch !== "function") {
      throw new Error("onSearch must be a valid function");
    }
    if (typeof initialSearchQuery !== "string") {
      throw new Error("initialSearchQuery must be a string");
    }
    this.currentSearch = initialSearchQuery;
    this.initializeSearch();
  }
  initializeSearch() {
    this.searchEl = this.container.createEl("input", {
      cls: TIMELINE_CLASSES.TIMELINE_SEARCH,
      attr: {
        type: "text",
        placeholder: "Search events...",
        value: this.currentSearch
      }
    });
    this.searchButton = this.container.createEl("button", {
      cls: TIMELINE_CLASSES.TIMELINE_SEARCH_BUTTON
    });
    (0, import_obsidian3.setIcon)(this.searchButton, "search");
    this.searchButton.setAttribute("aria-label", TIMELINE_ARIA_LABELS.SEARCH_BUTTON);
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.searchButton.addEventListener("click", () => this.performSearch());
    this.searchEl.addEventListener("keyup", (e) => {
      if (e.key === "Enter") {
        this.performSearch();
      }
    });
  }
  performSearch() {
    this.currentSearch = this.searchEl.value;
    this.onSearch(this.currentSearch);
  }
  getCurrentSearch() {
    return this.currentSearch;
  }
  filterEvents(events) {
    if (!this.currentSearch) return events;
    const searchLower = this.currentSearch.toLowerCase();
    return events.filter(
      (event) => event.title.toLowerCase().includes(searchLower) || event.content.toLowerCase().includes(searchLower)
    );
  }
};

// src/utils/formatDate.ts
var import_dayjs = __toESM(require_dayjs_min());
var import_customParseFormat = __toESM(require_customParseFormat());
import_dayjs.default.extend(import_customParseFormat.default);
function formatDate(event, plugin) {
  if (!event) {
    throw new Error("event must be provided");
  }
  if (!plugin) {
    throw new Error("plugin must be provided");
  }
  const format = plugin.settings.dateFormat || "YYYY-MM-DD";
  const separator = getFormatSeparator(format);
  const monthValue = getMonthValue(event.month, format);
  const parts = createDateParts(event, monthValue);
  const segments = format.split(new RegExp(`[${separator}]+`));
  const filledSegments = segments.map((segment) => processFormatSegment(segment, parts, monthValue));
  return filledSegments.filter(Boolean).join(separator);
}
function getFormatSeparator(format) {
  var _a;
  return ((_a = format.match(/[^A-Za-z0-9]+/)) == null ? void 0 : _a[0]) || "-";
}
function getMonthValue(month, format) {
  if (!month) return "";
  const date = (0, import_dayjs.default)(`2000-${month.padStart(2, "0")}-01`);
  if (format.includes("MMMM")) {
    return date.format("MMMM");
  } else if (format.includes("MMM")) {
    return date.format("MMM");
  } else if (format.includes("MM")) {
    return month.padStart(2, "0");
  }
  return "";
}
function createDateParts(event, monthValue) {
  return {
    YYYY: event.year,
    MMMM: monthValue,
    MMM: monthValue,
    MM: event.month ? event.month.padStart(2, "0") : "",
    DD: event.day ? event.day.padStart(2, "0") : ""
  };
}
function processFormatSegment(segment, parts, monthValue) {
  let result = segment;
  if (result.includes("MMMM") && monthValue) {
    result = result.replace("MMMM", monthValue);
  } else if (result.includes("MMM") && monthValue) {
    result = result.replace("MMM", monthValue);
  } else if (result.includes("MM") && parts.MM) {
    result = result.replace("MM", parts.MM);
  }
  if (result.includes("YYYY")) {
    if (!parts.YYYY) return "";
    result = result.replace("YYYY", parts.YYYY);
  }
  if (result.includes("DD")) {
    if (!parts.DD) return "";
    result = result.replace("DD", parts.DD);
  }
  if (/YYYY|MM(MM?)?|DD/.test(result)) {
    return "";
  }
  return result;
}

// src/utils/timeline-renderer.ts
var TimelineEventContent = class extends import_obsidian4.MarkdownRenderChild {
  constructor(container, content, sourcePath, plugin) {
    super(container);
    this.content = content;
    this.sourcePath = sourcePath;
    this.plugin = plugin;
  }
  async onload() {
    await import_obsidian4.MarkdownRenderer.render(
      this.plugin.app,
      this.content,
      this.containerEl,
      this.sourcePath,
      this.plugin
    );
  }
};
function renderError(container, error) {
  if (!container || !(container instanceof HTMLElement)) {
    throw new Error("container must be a valid HTMLElement");
  }
  if (!error) {
    throw new Error("error must be provided");
  }
  const errorEl = container.createEl("div", { cls: "timeline-error" });
  const errorHeader = errorEl.createEl("div", { cls: "timeline-error-header" });
  (0, import_obsidian4.setIcon)(errorHeader.createSpan(), "alert-triangle");
  errorHeader.createSpan({ text: error.message, cls: "timeline-error-message" });
  if (error.details) {
    const errorDetails = errorEl.createEl("div", { cls: "timeline-error-details" });
    errorDetails.createSpan({ text: error.details });
    if (error.line) {
      errorDetails.createEl("div", {
        text: `Line ${error.line}`,
        cls: "timeline-error-line"
      });
    }
  }
  const helpText = errorEl.createEl("div", { cls: "timeline-error-help" });
  helpText.createSpan({ text: "Expected format:" });
  const example = helpText.createEl("pre", { cls: "timeline-error-example" });
  example.createSpan({
    text: `# 2024-03-21
## Event Title
Event content goes here...

---

# 2024
## Another Event
More content...`
  });
}
function renderTimelineEvents(container, events, plugin, sourcePath = "", initialOrder, searchQuery = "") {
  if (!container || !(container instanceof HTMLElement)) {
    throw new Error("container must be a valid HTMLElement");
  }
  if (!Array.isArray(events)) {
    throw new Error("events must be an array");
  }
  if (!plugin) {
    throw new Error("plugin must be provided");
  }
  if (typeof sourcePath !== "string") {
    throw new Error("sourcePath must be a string");
  }
  if (initialOrder && !Object.values(TIMELINE_ORDER).includes(initialOrder)) {
    throw new Error("initialOrder must be a valid timeline order");
  }
  if (typeof searchQuery !== "string") {
    throw new Error("searchQuery must be a string");
  }
  try {
    if (!(plugin instanceof TimelinePlugin)) {
      throw new Error("Invalid plugin instance");
    }
    const currentOrder = initialOrder != null ? initialOrder : plugin.settings.timelineOrder;
    let filteredEvents = events;
    const renderChildren = [];
    if (plugin.settings.showHeaderButtons) {
      const headerEl = container.createEl("div", { cls: TIMELINE_CLASSES.TIMELINE_HEADER });
      const search = new TimelineSearch(headerEl, (newSearchQuery) => {
        container.empty();
        const newRenderChildren = renderTimelineEvents(
          container,
          events,
          plugin,
          sourcePath,
          currentOrder,
          newSearchQuery
        );
        newRenderChildren.forEach((child) => plugin.addChild(child));
      }, searchQuery);
      const orderToggle = new TimelineOrderToggle(headerEl, currentOrder, (newOrder) => {
        container.empty();
        const newRenderChildren = renderTimelineEvents(
          container,
          events,
          plugin,
          sourcePath,
          newOrder,
          search.getCurrentSearch()
        );
        newRenderChildren.forEach((child) => plugin.addChild(child));
      });
      new TimelineAddButton(headerEl, plugin.app, (newEvent) => {
        events.push(newEvent);
        container.empty();
        renderTimelineEvents(container, events, plugin, sourcePath, currentOrder, search.getCurrentSearch());
      }, () => events.map((event) => `# ${event.year}${event.month ? "-" + event.month : ""}${event.day ? "-" + event.day : ""}
## ${event.title}
${event.content}`).join("\n---\n"));
      filteredEvents = search.filterEvents(events);
      filteredEvents = orderToggle.sortEvents(filteredEvents);
    }
    const timeline = container.createEl("div", { cls: TIMELINE_CLASSES.TIMELINE });
    for (const event of filteredEvents) {
      const eventEl = timeline.createEl("div", { cls: TIMELINE_CLASSES.TIMELINE_EVENT });
      const datePointContainer = eventEl.createEl("div", { cls: "timeline-date-point" });
      const dateDisplay = formatDate(event, plugin);
      datePointContainer.createEl("div", { cls: TIMELINE_CLASSES.TIMELINE_DATE, text: dateDisplay });
      datePointContainer.createEl("div", { cls: TIMELINE_CLASSES.TIMELINE_POINT });
      const contentEl = eventEl.createEl("div", { cls: TIMELINE_CLASSES.TIMELINE_CONTENT });
      contentEl.createEl("h3", { text: event.title });
      const markdownContent = contentEl.createDiv(TIMELINE_CLASSES.TIMELINE_MARKDOWN_CONTENT);
      const renderChild = new TimelineEventContent(
        markdownContent,
        event.content,
        sourcePath,
        plugin
      );
      renderChildren.push(renderChild);
    }
    return renderChildren;
  } catch (error) {
    container.empty();
    if (error instanceof Error) {
      const isValidationError = error.name === "TimelineValidationError";
      renderError(container, {
        message: isValidationError ? error.message : "An error occurred while rendering the timeline",
        type: "render",
        details: error.message,
        line: isValidationError ? error.line : void 0
      });
    } else {
      renderError(container, {
        message: "An unexpected error occurred",
        type: "render",
        details: String(error)
      });
    }
    return [];
  }
}

// src/views/TimelineView.ts
var VIEW_TYPE_TIMELINE = "timeline-view";
var TimelineView = class extends import_obsidian5.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    /** Current timeline content to display */
    this.content = "";
    if (!plugin) {
      throw new Error("plugin must be provided");
    }
  }
  /**
   * Returns the unique identifier for this view type
   */
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  /**
   * Returns the display name for this view
   */
  getDisplayText() {
    return "Timeline view";
  }
  /**
   * Called when the view is opened
   */
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("div", { cls: "timeline-container" });
  }
  /**
   * Sets the timeline content and triggers re-render
   */
  async setContent(content) {
    this.content = content;
    await this.renderContent();
  }
  /**
   * Renders the timeline content
   */
  async renderContent() {
    try {
      const container = this.containerEl.querySelector(".timeline-container");
      if (!container) {
        console.warn("Timeline container not found");
        return;
      }
      container.empty();
      const events = parseTimelineContent(this.content);
      const sortedEvents = sortTimelineEvents(events, this.plugin.settings.timelineOrder);
      const renderChildren = renderTimelineEvents(container, sortedEvents, this.plugin);
      renderChildren.forEach((child) => this.addChild(child));
    } catch (error) {
      console.error("Error rendering timeline content:", error);
      const container = this.containerEl.querySelector(".timeline-container");
      if (container) {
        container.innerHTML = '<div class="timeline-error">Error rendering timeline content</div>';
      }
    }
  }
};

// src/main.ts
var import_obsidian7 = require("obsidian");

// src/settings/SettingsTab.ts
var import_obsidian6 = require("obsidian");
var TimelineSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    if (!plugin) {
      throw new Error("plugin must be provided");
    }
    this.plugin = plugin;
  }
  /**
   * Displays the settings interface
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Timeline Settings" });
    new import_obsidian6.Setting(containerEl).setName("Default sort order").setDesc("Choose the default sort order for timeline events").addDropdown(
      (dropdown) => dropdown.addOption("asc", "Ascending (oldest first)").addOption("desc", "Descending (newest first)").setValue(this.plugin.settings.timelineOrder).onChange(async (value) => {
        this.plugin.settings.timelineOrder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Date format").setDesc("Customize how dates are displayed in the timeline. Use YYYY for year, MM for month, DD for day. Supports negative years.").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
        this.plugin.settings.dateFormat = value || "YYYY-MM-DD";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Show header buttons").setDesc("Show or hide the operation buttons in timeline headers").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showHeaderButtons).onChange(async (value) => {
        this.plugin.settings.showHeaderButtons = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/main.ts
var TimelinePlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    /** Timeline view instance */
    this.timelineView = null;
  }
  /**
   * Plugin initialization - called when the plugin is loaded
   */
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TimelineSettingTab(this.app, this));
    this.registerView(
      VIEW_TYPE_TIMELINE,
      (leaf) => this.timelineView = new TimelineView(leaf, this)
    );
    this.registerMarkdownCodeBlockProcessor("timeline", async (source, el, ctx) => {
      try {
        const container = el.createEl("div", { cls: "timeline-container" });
        const events = parseTimelineContent(source);
        const sortedEvents = sortTimelineEvents(events, this.settings.timelineOrder);
        const renderChildren = renderTimelineEvents(container, sortedEvents, this, ctx.sourcePath);
        renderChildren.forEach((child) => this.addChild(child));
      } catch (error) {
        const container = el.createEl("div", { cls: "timeline-container" });
        if (error instanceof Error) {
          renderError(container, {
            message: error.name === "TimelineValidationError" ? error.message : "An error occurred while parsing the timeline",
            type: "parse",
            details: error.message,
            line: error.line
          });
        } else {
          renderError(container, {
            message: "An unexpected error occurred",
            type: "parse",
            details: String(error)
          });
        }
      }
    });
  }
  /**
   * Load plugin settings from Obsidian's data storage
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Save plugin settings to Obsidian's data storage
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Activate the timeline view in the workspace
   */
  async activateView() {
    var _a;
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_TIMELINE)[0];
    if (!leaf) {
      leaf = (_a = workspace.getRightLeaf(false)) != null ? _a : workspace.getLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_TIMELINE });
    }
    workspace.revealLeaf(leaf);
  }
};

/* nosourcemap */